TSP Solver: CPU vs GPU Performance Comparison
This project contains two Python programs for the Traveling Salesman Problem (TSP): graph.py and tsp.py. The goal is to generate a complete graph with random distances, find the optimal solution using brute force, and compare performance between CPU and GPU (using CUDA with CuPy) implementations.
Project Structure

graph.py: Generates a complete graph with ( N=10 ) vertices, calculates random distances, plots the graph and the optimal path, and saves the data to JSON and Pickle files.
tsp.py: Loads the data generated by graph.py, solves the TSP using brute force on CPU and GPU, compares execution times, and plots the results.

Features
graph.py

Generates a complete graph with ( N=10 ) vertices (configurable).
Calculates Euclidean distances with a random variation of Â±20%.
Plots the graph with nodes, edges, and weights using NetworkX and Matplotlib.
Finds the optimal TSP solution using brute force.
Plots the optimal path found.
Saves data (coordinates, distance matrix, optimal path, and distance) to tsp_dados.json and tsp_dados.pkl files.

tsp.py

Loads data saved by graph.py.
Solves the TSP using brute force:
CPU: Sequential implementation with itertools.permutations.
GPU: Parallel implementation with CuPy, processing permutations in batches.


Calculates execution times and speedup (CPU vs. GPU).
Plots a visual comparison (execution times, speedup, optimal path, and results table).
Saves results to resultados_cpu_gpu.json.

Requirements

Python 3.6+
Libraries:
numpy
matplotlib
networkx
cupy (for GPU execution; optional)


Hardware (for GPU):
NVIDIA GPU with CUDA support.
CUDA drivers installed.


Operating System: Tested on Linux/Windows; compatible with any system supporting Python and CUDA.

Installation

Clone the repository or download the graph.py and tsp.py files.
Install the dependencies:pip install numpy matplotlib networkx


(Optional) For GPU support, install CuPy:pip install cupy

Ensure the CUDA Toolkit is installed and configured correctly.

Usage

Generate the Graph:Run graph.py to create the graph, compute the optimal solution, and save the data:
python graph.py


Outputs:
Plots of the complete graph and the optimal path.
Files tsp_dados.json and tsp_dados.pkl.




Compare CPU vs. GPU:Run tsp.py to solve the TSP and compare performance:
python tsp.py


Prerequisite: Run graph.py first to generate tsp_dados.json.
Outputs:
Execution times (CPU and GPU, if available).
GPU speedup relative to CPU.
Comparative plots and results table.
File resultados_cpu_gpu.json.




Note:

For ( N > 10 ) vertices, brute force computation may take significant time due to factorial growth (( (N-1)! )).
tsp.py displays a warning for ( N > 10 ) and prompts for confirmation to continue.



Example Output
graph.py

Generates a graph with 10 vertices.
Displays the distance matrix (partial) and coordinates.
Plots the graph and the optimal path.
Example console output:=== TRAVELING SALESMAN PROBLEM GRAPH GENERATOR ===
Generating graph with N=10 vertices...
Graph generated successfully!
Optimal path found: [0, 2, 5, 7, 9, 1, 4, 8, 3, 6, 0]
Total distance: 123.45
Data saved to 'tsp_dados.json' and 'tsp_dados.pkl'



tsp.py

Compares CPU and GPU (if available).
Example console output:=== TSP SOLVER: CPU vs GPU ===
Data loaded: 10 vertices
Known optimal solution: 123.45
CPU - Brute force completed in 0.1234 seconds
GPU - Brute force completed in 0.0987 seconds
Speedup: 1.25x
Results saved to 'resultados_cpu_gpu.json'



Notes

Scalability: The brute force algorithm is feasible only for ( N \leq 12 ) due to the exponential growth of permutations (( (N-1)! )). For larger instances, consider heuristic or metaheuristic algorithms (e.g., genetic algorithms).
GPU: The GPU implementation requires CuPy and a compatible NVIDIA GPU. If CuPy is not installed, the program runs only the CPU version.
Customization: To change the number of vertices, modify the N variable in graph.py (default: N=10).
Reproducibility: The random seed (np.random.seed(42)) ensures consistent results in graph.py.

Limitations

The GPU implementation in tsp.py processes permutations in batches but still generates all permutations on the CPU, which can be a bottleneck for large ( N ).
The program does not handle asymmetric TSP instances or cases with additional constraints.

Contributions
Contributions are welcome! To contribute:

Fork the repository.
Create a branch for your changes.
Submit a pull request with a clear description of the changes.

License
This project is distributed under the MIT License. See the LICENSE file (if available) for details.
Contact
For questions or suggestions, contact [your_email@example.com] or open an issue in the repository.
